-- USERS TABLE (replaces Firebase Auth + MongoDB User model)
-- Managed largely by Supabase Auth, but we use a public profiles table for additional data.

create table public.profiles (
  id uuid not null references auth.users on delete cascade,
  email text,
  full_name text,
  role text default 'user', 
  is_premium boolean default false,
  premium_expires_at timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  primary key (id),
  constraint profiles_role_check check (role in ('user', 'admin', 'premium'))
);

alter table public.profiles enable row level security;

create policy "Public profiles are viewable by everyone."
  on profiles for select
  using ( true );

create policy "Users can insert their own profile."
  on profiles for insert
  with check ( auth.uid() = id );

create policy "Users can update own profile."
  on profiles for update
  using ( auth.uid() = id );

-- SETTINGS TABLE (replaces MongoDB Settings model)
create table public.settings (
  id bigint generated by default as identity primary key,
  maintenance_mode boolean default false,
  ads_enabled boolean default true,
  google_publisher_id text default '',
  ad_slots jsonb default '{
    "homeHeader": true,
    "homeInFeed": true,
    "homeFooter": true,
    "homeSidebar": true,
    "toolHeader": true,
    "toolInContent": true,
    "toolFooter": true,
    "toolSidebar": true
  }',
  affiliate_ads jsonb default '[]',
  disabled_tools text[] default '{}',
  updated_at timestamptz default now()
);

alter table public.settings enable row level security;

create policy "Settings are viewable by everyone."
  on settings for select
  using ( true );

create policy "Only admins can update settings"
  on settings for all
  using ( auth.uid() in (
    select id from profiles where email like '%@yourdomain.com' -- Replace with admin check logic
  ));

-- NEWSLETTER TABLE
create table public.newsletter_subscribers (
  id bigint generated by default as identity primary key,
  email text unique not null,
  subscribed_at timestamptz default now()
);

alter table public.newsletter_subscribers enable row level security;

create policy "Anyone can subscribe"
  on newsletter_subscribers for insert
  with check ( true );

-- Function to handle new user signup automatically
create function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public.profiles (id, email, full_name)
  values (new.id, new.email, new.raw_user_meta_data ->> 'full_name');
  return new;
end;
$$;

-- Trigger the function every time a user is created
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- INSERT DEFAULT SETTINGS
insert into public.settings (maintenance_mode) values (false);

-- CMS CONTENT TABLE
create table public.cms_content (
  id bigint generated by default as identity primary key,
  key text unique not null,
  value text, 
  section text,
  updated_at timestamptz default now()
);
alter table public.cms_content enable row level security;
create policy "Public read cms" on cms_content for select using (true);
create policy "Admin write cms" on cms_content for all using (
  auth.uid() in (select id from profiles where email like '%@yourdomain.com') 
);

-- AD CAMPAIGNS TABLE (Self-Serve)
create table public.ad_campaigns (
  id bigint generated by default as identity primary key,
  name text not null,
  image_url text not null,
  link_url text not null,
  slot text not null,
  is_active boolean default true,
  impressions integer default 0,
  clicks integer default 0,
  created_at timestamptz default now()
);
alter table public.ad_campaigns enable row level security;
create policy "Public read ads" on ad_campaigns for select using (true);
create policy "Admin write ads" on ad_campaigns for all using ( auth.uid() in (select id from profiles where email like '%@yourdomain.com') );

-- TOOL METADATA OVERRIDES
create table public.tool_configs (
  id text primary key,
  is_active boolean default true,
  custom_title text,
  custom_description text,
  seo_keywords text[],
  updated_at timestamptz default now()
);
alter table public.tool_configs enable row level security;
create policy "Public read tools" on tool_configs for select using (true);
create policy "Admin write tools" on tool_configs for all using ( auth.uid() in (select id from profiles where email like '%@yourdomain.com') );

-- SECURITY LOGS
create table public.security_logs (
  id bigint generated by default as identity primary key,
  ip_address text,
  request_path text,
  event_type text not null, -- 'admin_access_attempt', 'unauthorized_admin_access', 'suspicious_activity'
  user_id uuid references auth.users(id) on delete set null,
  created_at timestamptz default now()
);
alter table public.security_logs enable row level security;
create policy "Admins can read logs" on security_logs for select using (
  auth.uid() in (select id from profiles where email like '%@yourdomain.com')
);
-- Allow server-side inserts (service role bypasses RLS, but for good measure if we insert from client side contexts which we shouldn't)
-- We will insert via Service Role in middleware or API routes mostly. 


